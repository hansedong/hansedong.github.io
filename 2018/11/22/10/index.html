<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kubernetes,kubedns,coredns,">










<meta name="description" content="KubeDNS简述KubeDNS，是K8S官方推荐的DNS解析组件之一，从 K8S 1.11 开始，K8S 已经使用 CoreDNS，替换 KubeDNS 来充当其 DNS 解析的重任。 KubeDNS的前身，是 skyDNS，这个组件，会把 DNS 的解析记录等数据，存储到 K8S 所使用的 etcd 集群中，我们这里不讨论这个，仅讨论现今的 KubeDNS，KubeDNS，并不把 DNS 的解">
<meta name="keywords" content="kubernetes,kubedns,coredns">
<meta property="og:type" content="article">
<meta property="og:title" content="CoreDNS系列2：KubeDNS 架构组成及实现原理">
<meta property="og:url" content="http://yoursite.com/2018/11/22/10/index.html">
<meta property="og:site_name" content="国南之境">
<meta property="og:description" content="KubeDNS简述KubeDNS，是K8S官方推荐的DNS解析组件之一，从 K8S 1.11 开始，K8S 已经使用 CoreDNS，替换 KubeDNS 来充当其 DNS 解析的重任。 KubeDNS的前身，是 skyDNS，这个组件，会把 DNS 的解析记录等数据，存储到 K8S 所使用的 etcd 集群中，我们这里不讨论这个，仅讨论现今的 KubeDNS，KubeDNS，并不把 DNS 的解">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/11/22/10/10-2.png">
<meta property="og:updated_time" content="2018-11-26T02:32:04.160Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoreDNS系列2：KubeDNS 架构组成及实现原理">
<meta name="twitter:description" content="KubeDNS简述KubeDNS，是K8S官方推荐的DNS解析组件之一，从 K8S 1.11 开始，K8S 已经使用 CoreDNS，替换 KubeDNS 来充当其 DNS 解析的重任。 KubeDNS的前身，是 skyDNS，这个组件，会把 DNS 的解析记录等数据，存储到 K8S 所使用的 etcd 集群中，我们这里不讨论这个，仅讨论现今的 KubeDNS，KubeDNS，并不把 DNS 的解">
<meta name="twitter:image" content="http://yoursite.com/2018/11/22/10/10-2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/22/10/">





  <title>CoreDNS系列2：KubeDNS 架构组成及实现原理 | 国南之境</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?74a7c642f7a0292e45cc64f132081563";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">国南之境</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/10/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="国南之境">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="国南之境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CoreDNS系列2：KubeDNS 架构组成及实现原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T23:43:00+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">kubernetes</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/kubernetes/kubedns/" itemprop="url" rel="index">
                    <span itemprop="name">kubedns</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/kubernetes/kubedns/coredns/" itemprop="url" rel="index">
                    <span itemprop="name">coredns</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/11/22/10/" class="leancloud_visitors" data-flag-title="CoreDNS系列2：KubeDNS 架构组成及实现原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="KubeDNS简述"><a href="#KubeDNS简述" class="headerlink" title="KubeDNS简述"></a>KubeDNS简述</h2><p>KubeDNS，是K8S官方推荐的DNS解析组件之一，从 K8S 1.11 开始，K8S 已经使用 CoreDNS，替换 KubeDNS 来充当其 DNS 解析的重任。</p>
<p>KubeDNS的前身，是 skyDNS，这个组件，会把 DNS 的解析记录等数据，存储到 K8S 所使用的 etcd 集群中，我们这里不讨论这个，仅讨论现今的 KubeDNS，KubeDNS，并不把 DNS 的解析规则存储到 etcd，而是放到进程的内存中，当 KubeDNS 的服务 POD 重启后，会重建一遍 DNS 规则到内存。</p>
<p>在前篇，我们已经了解了 K8S 中，DNS 解析的原理，本篇，我们侧重 KubeDNS 本身。包含下面几个点：</p>
<ol>
<li>KubeDNS 服务，包含了哪些组件，职责是什么？</li>
<li>KubeDNS 是如何区分 K8S 内部域名还是外部域名的？</li>
<li>KubeDNS 如何配置上游DNS服务器？</li>
<li>KubeDNS 如何配置自定义域名解析？</li>
<li>KubeDNS 解析 K8S 内部域名的的实现原理是什么？</li>
<li>KubeDNS 如何做弹性扩缩容？</li>
</ol>
<h2 id="KubeDNS组件构成"><a href="#KubeDNS组件构成" class="headerlink" title="KubeDNS组件构成"></a>KubeDNS组件构成</h2><p>在 K8S 中，KubeDNS 的实例是 POD，配置一个 KubeDNS 的 Service，对 KubeDNS 的 POD 进行匹配。在 K8S 的 其他 POD 中，使用这个 Service 的 IP 地址，作为 /etc/resolv.conf 里 nameserver 的地址，从而达到 POD 里使用 KubeDNS 的目的。这是 K8S 的默认行为，我们不需要手动干预。</p>
<blockquote>
<p>其实严格来说，是 Service 匹配 Endpoint，因为 POD 创建之后可能会有IP，但此IP可能是一个 POD 非 完全Ready 状态下的 IP，理论上，这种 IP 是无无法提供服务的，所以，说 Service 匹配 Endpoint 更合适一些。</p>
</blockquote>
<p>然而，KubeDNS POD 是由 Deployment 控制启动的，POD 中，并非只有一个容器。KubeDNS 的配置，是使用的 ConfigMap，总的来看，有2个主要资源：</p>
<p>一个标准 KubeDNS 的 Deployment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">    k8s-app: kube-dns</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: 600</span><br><span class="line">  replicas: 2</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kube-dns</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 10%</span><br><span class="line">      maxUnavailable: 0</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      annotations:</span><br><span class="line">        scheduler.alpha.kubernetes.io/critical-pod: &quot;&quot;</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kube-dns</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - preference:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: node-role.kubernetes.io/master</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">            weight: 100</span><br><span class="line">        podAntiAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchLabels:</span><br><span class="line">                k8s-app: kube-dns</span><br><span class="line">            topologyKey: kubernetes.io/hostname</span><br><span class="line">      containers:</span><br><span class="line">      - args:</span><br><span class="line">        - --domain=cluster.local.</span><br><span class="line">        - --dns-port=10053</span><br><span class="line">        - --config-dir=/kube-dns-config</span><br><span class="line">        - --v=2</span><br><span class="line">        env:</span><br><span class="line">        - name: PROMETHEUS_PORT</span><br><span class="line">          value: &quot;10055&quot;</span><br><span class="line">        image: gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.10</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        livenessProbe:</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/kubedns</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        name: kubedns</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-local</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 10053</span><br><span class="line">          name: dns-tcp-local</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 10055</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        readinessProbe:</span><br><span class="line">          failureThreshold: 3</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /readiness</span><br><span class="line">            port: 8081</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 3</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            memory: 170Mi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 70Mi</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /kube-dns-config</span><br><span class="line">          name: kube-dns-config</span><br><span class="line">      - args:</span><br><span class="line">        - -v=2</span><br><span class="line">        - -logtostderr</span><br><span class="line">        - -configDir=/etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">        - -restartDnsmasq=true</span><br><span class="line">        - --</span><br><span class="line">        - -k</span><br><span class="line">        - --cache-size=1000</span><br><span class="line">        - --dns-loop-detect</span><br><span class="line">        - --log-facility=-</span><br><span class="line">        - --server=/cluster.local/127.0.0.1#10053</span><br><span class="line">        - --server=/in-addr.arpa/127.0.0.1#10053</span><br><span class="line">        - --server=/ip6.arpa/127.0.0.1#10053</span><br><span class="line">        image: gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.10</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        livenessProbe:</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthcheck/dnsmasq</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        name: dnsmasq</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns</span><br><span class="line">          protocol: UDP</span><br><span class="line">        - containerPort: 53</span><br><span class="line">          name: dns-tcp</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 150m</span><br><span class="line">            memory: 20Mi</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: /etc/k8s/dns/dnsmasq-nanny</span><br><span class="line">          name: kube-dns-config</span><br><span class="line">      - args:</span><br><span class="line">        - --v=2</span><br><span class="line">        - --logtostderr</span><br><span class="line">        - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,A</span><br><span class="line">        - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local,5,A</span><br><span class="line">        image: gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.10</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        livenessProbe:</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /metrics</span><br><span class="line">            port: 10054</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 60</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">        name: sidecar</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 10054</span><br><span class="line">          name: metrics</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 10m</span><br><span class="line">            memory: 20Mi</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      dnsPolicy: Default</span><br><span class="line">      nodeSelector:</span><br><span class="line">        beta.kubernetes.io/os: linux</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: default-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      serviceAccount: kube-dns</span><br><span class="line">      serviceAccountName: kube-dns</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: CriticalAddonsOnly</span><br><span class="line">        operator: Exists</span><br><span class="line">      - effect: NoSchedule</span><br><span class="line">        key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Equal</span><br><span class="line">      volumes:</span><br><span class="line">      - configMap:</span><br><span class="line">          defaultMode: 420</span><br><span class="line">          name: kube-dns</span><br><span class="line">          optional: true</span><br><span class="line">        name: kube-dns-config</span><br></pre></td></tr></table></figure>
<p>从这个 Deployment 可以看到2个重点：</p>
<ol>
<li>KubeDNS 使用 名称为 kube-dns 的 ConfigMap 作为其配置（ConfigMap没有，POD也可以运行）。</li>
<li>KubeDNS 使用了3个容器，组合提供DNS服务。</li>
</ol>
<h2 id="KubeDNS组件构成及实现"><a href="#KubeDNS组件构成及实现" class="headerlink" title="KubeDNS组件构成及实现"></a>KubeDNS组件构成及实现</h2><p>KubeDNS，使用3个容器组合服务，分别是：dnsmasq、kube-dns、sidecar，这3者，职责不同，整个DNS架构组成如下：</p>
<p><img src="/2018/11/22/10/10-2.png" alt="采样图"></p>
<p>POD的DNS请求打到 dnsmasq 容器的53端口，dnsmasq 决定此请求时自己处理，还是转到 kubedns 容器处理。各组件具体职责：</p>
<h3 id="dnsmasq-容器"><a href="#dnsmasq-容器" class="headerlink" title="dnsmasq 容器"></a>dnsmasq 容器</h3><p>dnsmasq 容器：负责整个 KubeDNS 的请求入口，53端口，就是它开放的，因此，在 K8S 中，内部域名和外部域名请求处理的区分，也是 dnsmasq 来做的。它充当 DNS 的请求入口，有几个作用：</p>
<ol>
<li>充当 DNS 请求入口。</li>
<li>区别 K8S 内部和外部域名走不通的策略。</li>
<li>DNS 缓存，进行过DNS请求后的域名会进行缓存，提高DNS请求效率。</li>
</ol>
<p>在此容器的启动参数包含下面部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- --server=/cluster.local/127.0.0.1#10053</span><br><span class="line">- --server=/in-addr.arpa/127.0.0.1#10053</span><br><span class="line">- --server=/ip6.arpa/127.0.0.1#10053</span><br></pre></td></tr></table></figure>
<p>这个参数说明，cluster.local 结尾的域名（这种是 K8S 的内部域名，不理解为什么这种是 K8S 内部域名的，可以翻看之前的文章），dnsmasq 进程会把此 DNS 请求，转发到 127.0.0.1:10053 端口上。而 10053 端口，是 kube-dns容器进程，正是监听的 10053 端口。所以说， dnsmasq 通过 - –server=/cluster.local/127.0.0.1#10053 这个配置，来决策 K8S 内部的域名的 DNS 请求，往 kube-dns 容器转发。</p>
<blockquote>
<p>dnsmasq 先解析本地 /etc/hosts 文件<br>再解析 /etc/dnsmasq.d/*.conf 文件<br>然后解析 /etc/dnsmasq.conf<br>最后解析自定义上游DNS的部分，也就是 /etc/dnsmasq.conf 中 resolv-file 的字段部分，一般我们将 resolv-file 字段配置为 /etc/resolv.conf。</p>
</blockquote>
<h3 id="dnsmasq为KubeDNS提供缓存加速能力"><a href="#dnsmasq为KubeDNS提供缓存加速能力" class="headerlink" title="dnsmasq为KubeDNS提供缓存加速能力"></a>dnsmasq为KubeDNS提供缓存加速能力</h3><p>KubeDNS 缓存，其实，利用的便是 dnsmasq 具备的缓存能力。另外，缓存，在 KubeDNS 中非常重要，能最大程度的发挥 DNS 响应效率，我们通过一个实际例子测试一下：</p>
<p>第一次请求一个不存在的域名时，第一次 DNS 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@test8-5646b97977-p6z8p /]# dig jjjjjjjj1212121212.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7_5.1 &lt;&lt;&gt;&gt; jjjjjjjj1212121212.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 61155</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;jjjjjjjj1212121212.com.                IN      A</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">com.                    900     IN      SOA     a.gtld-servers.net. nstld.verisign-grs.com. 1542785400 1800 900 604800 86400</span><br><span class="line"></span><br><span class="line">;; Query time: 864 msec</span><br><span class="line">;; SERVER: 10.233.0.3#53(10.233.0.3)</span><br><span class="line">;; WHEN: Wed Nov 21 07:30:18 UTC 2018</span><br><span class="line">;; MSG SIZE  rcvd: 113</span><br></pre></td></tr></table></figure>
<p>请求耗时 864ms，耗时相当长。<br>再次执行 DNS 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@test8-5646b97977-p6z8p /]# dig jjjjjjjj1212121212.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7_5.1 &lt;&lt;&gt;&gt; jjjjjjjj1212121212.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NXDOMAIN, id: 60767</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;jjjjjjjj1212121212.com.                IN      A</span><br><span class="line"></span><br><span class="line">;; Query time: 1 msec</span><br><span class="line">;; SERVER: 10.233.0.3#53(10.233.0.3)</span><br><span class="line">;; WHEN: Wed Nov 21 07:41:35 UTC 2018</span><br><span class="line">;; MSG SIZE  rcvd: 51</span><br></pre></td></tr></table></figure>
<p>请求耗时仅仅1毫秒。加速效果相当明显。</p>
<h3 id="dnsmasq-容器内的进程组成及职责"><a href="#dnsmasq-容器内的进程组成及职责" class="headerlink" title="dnsmasq 容器内的进程组成及职责"></a>dnsmasq 容器内的进程组成及职责</h3><p>dnamasq 容器内，其实有2个进程，一个是 dnsmasq-nanny，一个是 dnsmamsq。其实，我们上面看到的 KubeDNS 的 deployment 里关于 kube-dns 容器的配置里的相关参数，并不是直接对 dnsmasq 进程生效的，而是对 dnsmasq-nanny 进程生效的。</p>
<p>dnsmasq-nanny 进程，是 dnsmasq 容器进程的1号进程，是保姆进程，而 dnsmasq 进程，就是由 dnsmasq-nanny 进程 fork 出来的，dnsmasq-nanny 具备 fork、restart 及传递配置参数给 dnsmasq 进程的能力。</p>
<p>我们可以通过进程树来看 dnsmasq-nanny 和 dnsmasq 的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 查看进程树</span><br><span class="line">/ # pstree -p</span><br><span class="line">dnsmasq-nanny(1)---dnsmasq(30)</span><br><span class="line">// dnsmasq-nanny 是 dnsmasq 的父进程。</span><br><span class="line"></span><br><span class="line">// 通过 ps 命令也可以看出来，dnsmasq 的参数，是 dnsmasq-nanny 传过去的</span><br><span class="line">/ # cat sss </span><br><span class="line">PID   USER     TIME   COMMAND</span><br><span class="line">    1 root      12:38 /dnsmasq-nanny -v=2 -logtostderr -configDir=/etc/k8s/dns/dnsmasq-nanny -restartDnsmasq=true -- -k --cache-size=1000 --log-facility=- --server=/cluster.local/127.0.0.1#10053 --server=/in-addr.arpa/127.0.0.1#10053 --server=/ip6.arpa/127.0.0.1#10053</span><br><span class="line">   30 root     268:54 /usr/sbin/dnsmasq -k --cache-size=1000 --log-facility=- --server=/cluster.local/127.0.0.1#10053 --server=/in-addr.arpa/127.0.0.1#10053 --server=/ip6.arpa/127.0.0.1#10053</span><br></pre></td></tr></table></figure>
<p>既然 dnsmasq-nanny 是保姆进程，其有几个重要参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// dnsmasq-nanny 进程的配置目录，这个目录，是需要挂载 configmap 类型 Volume 到此目录的</span><br><span class="line">-configDir=/etc/k8s/dns/dnsmasq-nanny</span><br><span class="line"></span><br><span class="line">// 开启配置检测，当配置发生变更时，重启 dnsmasq 进程</span><br><span class="line">-restartDnsmasq=true</span><br></pre></td></tr></table></figure>
<h3 id="dnsmasq-容器负责让KubeDNS更新配置生效"><a href="#dnsmasq-容器负责让KubeDNS更新配置生效" class="headerlink" title="dnsmasq 容器负责让KubeDNS更新配置生效"></a>dnsmasq 容器负责让KubeDNS更新配置生效</h3><p>更新配置很简单，只需要更新名称为 kube-dns 的 ConfigMap 的内容，即可，但这里我们主要从源码角度，讲一下原理是什么。首先再次明确一遍，KubeDNS由多个组件构成，但真正负责处理配置更新的，只有 dnsmasq 容器的 dnsmasq-nanny 进程。</p>
<p>我们通过部分源码，也可以看出来，dnsmasq-nanny 是 如何 重启 dnsmasq 进程的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// dns/pkg/dnsmasq/nanny.go#169</span><br><span class="line"></span><br><span class="line">// RunNanny runs the nanny and handles configuration updates.</span><br><span class="line">func RunNanny(sync config.Sync, opts RunNannyOpts) &#123;</span><br><span class="line">    defer glog.Flush()</span><br><span class="line"></span><br><span class="line">    currentConfig, err := sync.Once()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        glog.Errorf(&quot;Error getting initial config, using default: %v&quot;, err)</span><br><span class="line">        currentConfig = config.NewDefaultConfig()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nanny := &amp;Nanny&#123;Exec: opts.DnsmasqExec&#125;</span><br><span class="line">    nanny.Configure(opts.DnsmasqArgs, currentConfig)</span><br><span class="line">    if err := nanny.Start(); err != nil &#123;</span><br><span class="line">        glog.Fatalf(&quot;Could not start dnsmasq with initial configuration: %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configChan := sync.Periodic()</span><br><span class="line"></span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case status := &lt;-nanny.ExitChannel:</span><br><span class="line">            glog.Flush()</span><br><span class="line">            glog.Fatalf(&quot;dnsmasq exited: %v&quot;, status)</span><br><span class="line">            break</span><br><span class="line">        case currentConfig = &lt;-configChan:</span><br><span class="line">          // 如果接受到新的配置的数据变化，先杀掉dnsmasq，再使用最新配置，启动一个新的dnsmasq进程</span><br><span class="line">            if opts.RestartOnChange &#123;</span><br><span class="line">                glog.V(0).Infof(&quot;Restarting dnsmasq with new configuration&quot;)</span><br><span class="line">                nanny.Kill()</span><br><span class="line">                nanny = &amp;Nanny&#123;Exec: opts.DnsmasqExec&#125;</span><br><span class="line">                nanny.Configure(opts.DnsmasqArgs, currentConfig)</span><br><span class="line">                nanny.Start()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                glog.V(2).Infof(&quot;Not restarting dnsmasq (--restartDnsmasq=false)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，配置是什么时候产生变化的呢？</p>
<p>dnsmasq-nanny 进程处理配置变化的方式比较粗暴，如果设置了 -configDir 配置目录的话，此进程会间隔 10s ，进行一次配置检测，如果发生变化，就 重启 dnsmasq。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// dns/cmd/dnsmasq-nanny/main.go#72</span><br><span class="line"></span><br><span class="line">// 进程启动入口部分</span><br><span class="line">func main() &#123;</span><br><span class="line">    parseFlags()</span><br><span class="line">    glog.V(0).Infof(&quot;opts: %v&quot;, opts)</span><br><span class="line"></span><br><span class="line">  // 运行 dnsmasq-nanny 之前，做配置变化的检测</span><br><span class="line">    sync := config.NewFileSync(opts.configDir, opts.syncInterval)</span><br><span class="line"></span><br><span class="line">    dnsmasq.RunNanny(sync, opts.RunNannyOpts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// dns/pkg/dns/config/sync.go#81</span><br><span class="line"></span><br><span class="line">// 计划任务，检测配置目录里的文件，是否发生变化，发生了，则返回</span><br><span class="line">func (sync *kubeSync) Periodic() &lt;-chan *Config &#123;</span><br><span class="line">  // 检测配置变更的动作，用协程开启，异步进行</span><br><span class="line">    go func() &#123;</span><br><span class="line">      // 开启一个间隔为 10s 的计划任务，每次获取最新的配置版本和数据</span><br><span class="line">      // resultChan 是一个结构体，核心，是一个版本，以及这个版本对应的所有文件名及文件数据</span><br><span class="line">      // 它只是获取数据的版本和具体数据，数据是否变了，sync.syncSource.Periodic 并不管</span><br><span class="line">        resultChan := sync.syncSource.Periodic()</span><br><span class="line">        for &#123;</span><br><span class="line">            syncResult := &lt;-resultChan</span><br><span class="line">            // 这里是判断是否数据发生了变化，如果是，则将最新的数据返回</span><br><span class="line">            // 后边，我们会看，这个操作是怎么判断数据产生了变化的</span><br><span class="line">            config, changed, err := sync.processUpdate(syncResult, false)</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            if !changed &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            // 返回最新数据（如果走到这一步，说明配置绝对发送了变化，否则会在上面的步骤继续走循环逻辑）</span><br><span class="line">            sync.channel &lt;- config</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    return sync.channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看，是如何判断文件发生变化的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// dns/pkg/dns/config/sync.go#99</span><br><span class="line"></span><br><span class="line">//判断数据是否产生了变化</span><br><span class="line">func (sync *kubeSync) processUpdate(result syncResult, buildUnchangedConfig bool) (config *Config, changed bool, err error) &#123;</span><br><span class="line">    glog.V(4).Infof(&quot;processUpdate %+v&quot;, result)</span><br><span class="line"></span><br><span class="line">  // 这里是判断核心，如果 sync 对象中保存的版本，与 result 对象中保存的版本不同，则认为数据发生了变化</span><br><span class="line">    if result.Version != sync.latestVersion &#123;</span><br><span class="line">        glog.V(3).Infof(&quot;Updating config to version %v (was %v)&quot;,</span><br><span class="line">            result.Version, sync.latestVersion)</span><br><span class="line">        changed = true</span><br><span class="line">        sync.latestVersion = result.Version</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        glog.V(4).Infof(&quot;Config was unchanged (version %v)&quot;, sync.latestVersion)</span><br><span class="line">        // short-circuit if we haven&apos;t been asked to build an unchanged config object</span><br><span class="line">        if !buildUnchangedConfig &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if result.Version == &quot;&quot; &amp;&amp; len(result.Data) == 0 &#123;</span><br><span class="line">        config = NewDefaultConfig()</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 下面都是解析配置的过程了，无需细看</span><br><span class="line">    config = &amp;Config&#123;&#125;</span><br><span class="line"></span><br><span class="line">    for key, updateFn := range map[string]fieldUpdateFn&#123;</span><br><span class="line">        &quot;federations&quot;:         updateFederations,</span><br><span class="line">        &quot;stubDomains&quot;:         updateStubDomains,</span><br><span class="line">        &quot;upstreamNameservers&quot;: updateUpstreamNameservers,</span><br><span class="line">    &#125; &#123;</span><br><span class="line">        value, ok := result.Data[key]</span><br><span class="line">        if !ok &#123;</span><br><span class="line">            glog.V(3).Infof(&quot;No %v present&quot;, key)</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if err = updateFn(key, value, config); err != nil &#123;</span><br><span class="line">            glog.Errorf(&quot;Invalid configuration for %v, ignoring update: %v&quot;, key, err)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if err = config.Validate(); err != nil &#123;</span><br><span class="line">        glog.Errorf(&quot;Invalid configuration: %v (value was %+v), ignoring update&quot;, err, config)</span><br><span class="line">        config = nil</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上：dnsmasq-nanny 保姆进程，会一直检测自己参数 -configDir 配置的目录里的文件是否发生了变化，判断的逻辑是：每隔10秒钟，读取一次这个目录下的所有【配置文件数据】（一个Map，key为文件名，值为文件内容），用 sha256 计算一次摘要，作为这个目录下所有数据的版本。然后记录下来，下次的时候执行同样的逻辑，如果发现版本不同，则认为配置文件发送了变化。然后将得到的【配置文件数据】重新解析为 dnsmasq-nanny 的配置数据，最后，杀死 dnsmasq 进程，启动一个系的 dnsmasq 进程。但是，这里边，有几个细节点：</p>
<p>第一：重启 dnsmasq 的方式，先杀后起，方式台粗暴，很可能导致这个时间点的大量DNS请求失败。不优雅。</p>
<p>第二：dnsmasq-nanny 检测数据变化的方式，这种方式就有2个值得注意的问题：</p>
<blockquote>
<p>①：官方是，每次遍历目录下的所有文件，然后，使用 ioutil.ReadFile 读取文件内容。如果目录下文件多，可能导致，你遍历的同时，配置文件也在变化，你遍历的速度和文件更新速度不一致，导致，读取的配置，并不一定是最新的，可能你遍历完，某个配置文件才更新完。那么此时，你读取的一部分文件数据并不是和当前目录下文件数据完全一致，本次会重启 dnsmasq。进而，下次检测，还认为有文件变化，到时候，又重启一次 dnsmasq。这种方式不优雅，但问题不大。</p>
</blockquote>
<blockquote>
<p>②：文件的检测，直接使用  ioutil.ReadFile 读取文件内容，也存在问题。如果文件变化，和文件读取同时发生，很可能你读取完，文件的更新都没完成，那么你读取的并非一个完整的文件，而是坏的文件，这种文件，dnsmasq-nanny 无法做解析，不过官方代码中有数据校验，解析失败也问题不大，大不了下个周期的时候，再取到完整数据，再解析一次。</p>
</blockquote>
<h3 id="kube-dns服务容器及实现原理"><a href="#kube-dns服务容器及实现原理" class="headerlink" title="kube-dns服务容器及实现原理"></a>kube-dns服务容器及实现原理</h3><p>讲完 KubeDNS 服务的 dnsmasq 容器，现在开始 kube-dns 容器。kube-dns 容器，最主要的职责，就是负责解析 K8S 的内部域名记录，这个解析，它监听了 10053 端口，本质上，kube-dns 是接受 dnsmasq 请求的（ dnsmasq 容器负责处理所有 DNS 请求，对于 K8S 的内部域名请求，转发给 kube-dns 来处理）。 </p>
<p>kube-dns 的进程职责是，监视Kubernetes master上 Service 和 Endpoint 的改变，并在内存中维护 lookup 结构用于服务DNS请求。</p>
<p>此容器启动参数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- --domain=cluster.local.</span><br><span class="line">- --dns-port=10053</span><br><span class="line">- --config-dir=/kube-dns-config</span><br><span class="line">- --v=2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>–domain：表示在哪个domain下创建域名记录。<br>–dns-port：这个是启动端口。<br>–config-dir：这个是使用的配置，通常来说，我们的 KubeDNS POD，会使用 ConfigMap，将配置挂载到容器内的 –config-dir 指定的目录上。</p>
</blockquote>
<p><strong>这里打算源码层面，追踪一下具体实现，但不打算从头追到尾，这样篇幅太大，只罗列一部分核心点。核心点内容包括</strong>：</p>
<ol>
<li>kube-dns 容器，都是监听的哪些 K8S 资源数据，作为域名记录的解析依据？</li>
<li>kube-dns 使用什么技术或数据结构实现内存级数据查询的？</li>
<li>如果 K8S 有 Service 资源，但没有对应的 POD 资源，域名解析是否还能成功？</li>
</ol>
<h4 id="kube-dns容器监听哪些K8S资源？"><a href="#kube-dns容器监听哪些K8S资源？" class="headerlink" title="kube-dns容器监听哪些K8S资源？"></a>kube-dns容器监听哪些K8S资源？</h4><p>我们知道，K8S 内部域名的 DNS 解析，得到的是 Service 的 IP 地址。kube-dns 肯定监听了 Service 资源了，为的是，处理内部域名映射到 Service 的 IP 地址。从源码看，其实 kube-dns 容器，其实监听了2个资源，分别是：</p>
<ul>
<li>Service 资源</li>
<li>Endpoints 资源</li>
</ul>
<p>至于为何还需要监听 Endpoints 资源，我们一步步解开谜底</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 开启一个 KubeDNS 处理实例</span><br><span class="line">func NewKubeDNS(client clientset.Interface, clusterDomain string, timeout time.Duration, configSync config.Sync) *KubeDNS &#123;</span><br><span class="line">    kd := &amp;KubeDNS&#123;</span><br><span class="line">        kubeClient:          client,</span><br><span class="line">        domain:              clusterDomain,</span><br><span class="line">        cache:               treecache.NewTreeCache(),</span><br><span class="line">        cacheLock:           sync.RWMutex&#123;&#125;,</span><br><span class="line">        nodesStore:          kcache.NewStore(kcache.MetaNamespaceKeyFunc),</span><br><span class="line">        reverseRecordMap:    make(map[string]*skymsg.Service),</span><br><span class="line">        clusterIPServiceMap: make(map[string]*v1.Service),</span><br><span class="line">        domainPath:          util.ReverseArray(strings.Split(strings.TrimRight(clusterDomain, &quot;.&quot;), &quot;.&quot;)),</span><br><span class="line">        initialSyncTimeout:  timeout,</span><br><span class="line"></span><br><span class="line">        configLock: sync.RWMutex&#123;&#125;,</span><br><span class="line">        configSync: configSync,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 监听并处理 Endpoints 资源</span><br><span class="line">    kd.setEndpointsStore()</span><br><span class="line">    // 监听并处理 Services 资源</span><br><span class="line">    kd.setServicesStore()</span><br><span class="line"></span><br><span class="line">    return kd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// setServicesStore 负责处理 Service 资源</span><br><span class="line">func (kd *KubeDNS) setServicesStore() &#123;</span><br><span class="line">    // Returns a cache.ListWatch that gets all changes to services.</span><br><span class="line">    kd.servicesStore, kd.serviceController = kcache.NewInformer(</span><br><span class="line">        kcache.NewListWatchFromClient(</span><br><span class="line">            kd.kubeClient.Core().RESTClient(),</span><br><span class="line">            &quot;services&quot;,</span><br><span class="line">            v1.NamespaceAll,</span><br><span class="line">            fields.Everything()),</span><br><span class="line">        &amp;v1.Service&#123;&#125;,</span><br><span class="line">        resyncPeriod,</span><br><span class="line">        // 这里也可以看出来，它其实主要针对 Service 的 增删改做 handle 处理</span><br><span class="line">        kcache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    kd.newService,</span><br><span class="line">            DeleteFunc: kd.removeService,</span><br><span class="line">            UpdateFunc: kd.updateService,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同上</span><br><span class="line">func (kd *KubeDNS) setEndpointsStore() &#123;</span><br><span class="line">    // Returns a cache.ListWatch that gets all changes to endpoints.</span><br><span class="line">    kd.endpointsStore, kd.endpointsController = kcache.NewInformer(</span><br><span class="line">        kcache.NewListWatchFromClient(</span><br><span class="line">            kd.kubeClient.Core().RESTClient(),</span><br><span class="line">            &quot;endpoints&quot;,</span><br><span class="line">            v1.NamespaceAll,</span><br><span class="line">            fields.Everything()),</span><br><span class="line">        &amp;v1.Endpoints&#123;&#125;,</span><br><span class="line">        resyncPeriod,</span><br><span class="line">        kcache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">            AddFunc:    kd.handleEndpointAdd,</span><br><span class="line">            UpdateFunc: kd.handleEndpointUpdate,</span><br><span class="line">            // If Service is named headless need to remove the reverse dns entries.</span><br><span class="line">            DeleteFunc: kd.handleEndpointDelete,</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下，如果 K8S 有 Service 资源创建出来，kube-dns 容器都做些什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 针对 K8S 中 Service 资源的创建，做处理</span><br><span class="line">func (kd *KubeDNS) newService(obj interface&#123;&#125;) &#123;</span><br><span class="line">    if service, ok := assertIsService(obj); ok &#123;</span><br><span class="line">        glog.V(3).Infof(&quot;New service: %v&quot;, service.Name)</span><br><span class="line">        glog.V(4).Infof(&quot;Service details: %v&quot;, service)</span><br><span class="line"></span><br><span class="line">    // 1、如果 Service 是 ExternaName 类型，则创建 cname 记录</span><br><span class="line">    // 稍微提一下，K8S 中的 Service，有几种类型：ClusterIP、NodePort、LoadBalancer、ExternaName</span><br><span class="line">    </span><br><span class="line">        // ExternalName services are a special kind that return CNAME records</span><br><span class="line">        if service.Spec.Type == v1.ServiceTypeExternalName &#123;</span><br><span class="line">            kd.newExternalNameService(service)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 2、如果是无头服务，则处理无头服务方式的DNS记录（A记录），无头服务的域名记录有些不同，所以这里是单独进行处理的</span><br><span class="line">        // 需要说明的是，我们刚刚提到的 Endpoints 资源，其实主要就是用在无头服务上的。</span><br><span class="line">        </span><br><span class="line">        // if ClusterIP is not set, a DNS entry should not be created</span><br><span class="line">        if !v1.IsServiceIPSet(service) &#123;</span><br><span class="line">            if err := kd.newHeadlessService(service); err != nil &#123;</span><br><span class="line">                glog.Errorf(&quot;Could not create new headless service %v: %v&quot;, service.Name, err)</span><br><span class="line">            &#125;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if len(service.Spec.Ports) == 0 &#123;</span><br><span class="line">            glog.Warningf(&quot;Service with no ports, this should not have happened: %v&quot;,</span><br><span class="line">                service)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 3、创建正常的 Service DNS 记录</span><br><span class="line">        kd.newPortalService(service)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到，Service 的创建操作，会涉及到 newHeadlessService 无头服务域名记录的操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 创建无头服务Service的域名记录</span><br><span class="line"></span><br><span class="line">// Generates skydns records for a headless service.</span><br><span class="line">func (kd *KubeDNS) newHeadlessService(service *v1.Service) error &#123;</span><br><span class="line">    // Create an A record for every pod in the service.</span><br><span class="line">    // This record must be periodically updated.</span><br><span class="line">    // Format is as follows:</span><br><span class="line">    // For a service x, with pods a and b create DNS records,</span><br><span class="line">    // a.x.ns.domain. and, b.x.ns.domain.</span><br><span class="line">    key, err := kcache.MetaNamespaceKeyFunc(service)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 根据 Service 名称获取key，在根据 Key，获取这个 Service 下的 Endpoints，用来生成特殊的无头服务的域名记录</span><br><span class="line">    e, exists, err := kd.endpointsStore.GetByKey(key)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return fmt.Errorf(&quot;failed to get endpoints object from endpoints store - %v&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果这个 Service 下没有 Endpoints，将不生成域名记录，一旦有endpoints之后，就会生成。</span><br><span class="line">    if !exists &#123;</span><br><span class="line">        glog.V(1).Infof(&quot;Could not find endpoints for service %q in namespace %q. DNS records will be created once endpoints show up.&quot;,</span><br><span class="line">            service.Name, service.Namespace)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    if e, ok := e.(*v1.Endpoints); ok &#123;</span><br><span class="line">        return kd.generateRecordsForHeadlessService(e, service)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Service 下没有Endpoints，不处理，一旦有 Endpoints 产生，立即生成域名记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根据 Endpoints，创建无头服务记录</span><br><span class="line">func (kd *KubeDNS) addDNSUsingEndpoints(e *v1.Endpoints) error &#123;</span><br><span class="line">  // 先根据 Endpoints 超出其属于哪个 Service</span><br><span class="line">    svc, err := kd.getServiceFromEndpoints(e)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断这个 Service 是不是无头服务的 Service，如果不是，直接返回</span><br><span class="line">    if svc == nil || v1.IsServiceIPSet(svc) || svc.Spec.Type == v1.ServiceTypeExternalName &#123;</span><br><span class="line">        // No headless service found corresponding to endpoints object.</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果是无头服务的 Service，生成域名记录</span><br><span class="line">    return kd.generateRecordsForHeadlessService(e, svc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kube-dns使用何种数据结构实现DNS检索？"><a href="#kube-dns使用何种数据结构实现DNS检索？" class="headerlink" title="kube-dns使用何种数据结构实现DNS检索？"></a>kube-dns使用何种数据结构实现DNS检索？</h4><p>参看后面附录</p>
<h3 id="dns-sidecar容器"><a href="#dns-sidecar容器" class="headerlink" title="dns-sidecar容器"></a>dns-sidecar容器</h3><h4 id="dns-sidecar容器职责简述"><a href="#dns-sidecar容器职责简述" class="headerlink" title="dns-sidecar容器职责简述"></a>dns-sidecar容器职责简述</h4><p>这是其实是一个健康监测容器，检查 dnsmasq 和 kube-dns 2个容器的监控状态。先回顾一下 sidecar 容器的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- args:</span><br><span class="line">  - --v=2</span><br><span class="line">  - --logtostderr</span><br><span class="line">  - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,A</span><br><span class="line">  - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local,5,A</span><br><span class="line">  image: gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.10</span><br></pre></td></tr></table></figure>
<p>这个容器，主要职责是探测 dnsmasq 以及 kubedns 服务的状态。但从上面 deployment 的参数，看不出太多东西，从源码角度可以看到更多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// sidecar 容器的默认启动参数</span><br><span class="line"></span><br><span class="line">// NewOptions creates a new options struct with default values.</span><br><span class="line">func NewOptions() *Options &#123;</span><br><span class="line">    return &amp;Options&#123;</span><br><span class="line">        DnsMasqAddr:           &quot;127.0.0.1&quot;,</span><br><span class="line">        DnsMasqPort:           53,</span><br><span class="line">        DnsMasqPollIntervalMs: 5000,</span><br><span class="line"></span><br><span class="line">    // sidecar 容器，开放了一个 10054 端口访问，这样一来，我们可以通过 Prometheus 来收集 sidecar 的数据。</span><br><span class="line">        PrometheusAddr:      &quot;0.0.0.0&quot;,</span><br><span class="line">        PrometheusPort:      10054,</span><br><span class="line">        PrometheusPath:      &quot;/metrics&quot;,</span><br><span class="line">        PrometheusNamespace: &quot;kubedns&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sidecar 容器，开放了一个 10054 端口访问，这样一来，我们可以通过 Prometheus 来收集 sidecar 的数据，另外需要说明的是，其实 sidecar 容器开放的 metrics 接口，暴露出来的数据，是 sidecar 探测 dnsmasq 以及 kube-dns 两个目标后，汇总的数据，数据包括：</p>
<ol>
<li>基本的 Go 应用性能数据（协程数量、CPU使用、打开的最大文件描述符数、内存使用等）</li>
<li>dnsmasq 容器发生的错误数</li>
<li>dnsmasq 容器已经发生的 DNS 缓存驱逐次数</li>
<li>dnsmasq 容器已经发生的 DNS 缓存插入次数</li>
<li>dnsmasq 容器缓存未命中次数</li>
<li>dnsmasq 域名解析失败次数</li>
<li>探测到的 dnsmasq 延迟时间</li>
</ol>
<h4 id="dns-sidecar-是如何做检测的"><a href="#dns-sidecar-是如何做检测的" class="headerlink" title="dns-sidecar 是如何做检测的"></a>dns-sidecar 是如何做检测的</h4><p>sidecar 的探测周期，默认为 5s 一次。–probe 指定了探测参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local,5,A</span><br></pre></td></tr></table></figure>
<p>表示：探测的服务“标签”为 kubedns，使用域名 kubernetes.default.svc.cluster.local ，将 A 记录类型的DNS解析请求，打到 127.0.0.1:10053 上。</p>
<blockquote>
<p>注意：这里的“标签”，是为某个DNS服务目标，打的一个标识而已，后边，这个“标签”会用到。主要是为了方便 通过 dns-sidecar 的 metrics 接口，访问到具体的某个“标签”的DNS服务的健康指标。</p>
</blockquote>
<p>指定多个 –probe 参数，则都会探测多个目标服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// dns/pkg/sidecar/server.go#43</span><br><span class="line"></span><br><span class="line">func (s *server) Run(options *Options) &#123;</span><br><span class="line">    s.options = options</span><br><span class="line">    glog.Infof(&quot;Starting server (options %+v)&quot;, *s.options)</span><br><span class="line"></span><br><span class="line">  // 循环遍历 probes 目标，然后开启探测</span><br><span class="line">    for _, probeOption := range options.Probes &#123;</span><br><span class="line">        probe := &amp;dnsProbe&#123;DNSProbeOption: probeOption&#125;</span><br><span class="line">        s.probes = append(s.probes, probe)</span><br><span class="line">        probe.Start(options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.runMetrics(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追一下是如何进行具体的DNS探测的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// dns/pkg/sidecar/dnsprobe.go#74</span><br><span class="line"></span><br><span class="line">func (p *dnsProbe) Start(options *Options) &#123;</span><br><span class="line">    glog.V(2).Infof(&quot;Starting dnsProbe %+v&quot;, p.DNSProbeOption)</span><br><span class="line"></span><br><span class="line">    p.lastError = fmt.Errorf(&quot;waiting for first probe&quot;)</span><br><span class="line"></span><br><span class="line">  // 为探测目标，定制抓们的 metrics URL，这样就可以通过 http://x.x.x.x:port/healthcheck/具体标签 的方式，来访问具体某个标签的DNS探测状态了。</span><br><span class="line">  // 这里的“标签”，其实就是之前我们提到的所用之处。</span><br><span class="line">    http.HandleFunc(&quot;/healthcheck/&quot;+p.Label, p.httpHandler)</span><br><span class="line">    p.registerMetrics(options)</span><br><span class="line"></span><br><span class="line">    if p.delayer == nil &#123;</span><br><span class="line">        glog.V(4).Infof(&quot;Using defaultLoopDelayer&quot;)</span><br><span class="line">        p.delayer = &amp;defaultLoopDelayer&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 异步探测动作</span><br><span class="line">    go p.loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的 DNS 探测动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// dns/okg/sidecar/dnsprobe.go#111</span><br><span class="line"></span><br><span class="line">func (p *dnsProbe) loop() &#123;</span><br><span class="line">    glog.V(4).Infof(&quot;Starting loop&quot;)</span><br><span class="line">    p.delayer.Start(p.Interval)</span><br><span class="line"></span><br><span class="line">  // 初始化一个dns客户端</span><br><span class="line">    dnsClient := &amp;dns.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line">  // 循环检测，用不退出</span><br><span class="line">    for &#123;</span><br><span class="line">        glog.V(4).Infof(&quot;Sending DNS request @%v %v&quot;, p.Server, p.Name)</span><br><span class="line">        // 发送一个 DNS 请求</span><br><span class="line">        msg, latency, err := dnsClient.Exchange(p.msg(), p.Server)</span><br><span class="line">        glog.V(4).Infof(&quot;Got response, err=%v after %v&quot;, err, latency)</span><br><span class="line"></span><br><span class="line">        if err == nil &amp;&amp; len(msg.Answer) == 0 &#123;</span><br><span class="line">            err = fmt.Errorf(&quot;no RRs for domain %q&quot;, p.Name)</span><br><span class="line">        &#125;</span><br><span class="line">    // 更新 DNS请求的metrics指标（延迟）数据</span><br><span class="line">        p.update(err, latency)</span><br><span class="line">        p.delayer.Sleep(latency)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KubeDNS-服务弹性水平伸缩"><a href="#KubeDNS-服务弹性水平伸缩" class="headerlink" title="KubeDNS 服务弹性水平伸缩"></a>KubeDNS 服务弹性水平伸缩</h2><h3 id="官方推荐方案：cluster-proportional-autoscaler"><a href="#官方推荐方案：cluster-proportional-autoscaler" class="headerlink" title="官方推荐方案：cluster-proportional-autoscaler"></a>官方推荐方案：cluster-proportional-autoscaler</h3><p>关于 KubeDNS 服务弹性伸缩，官方已经给出了一套比较简单的弹性水平扩缩容解决方案，下面是一套推荐的配置，用它来部署 KubeDNS 的 autoscaler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br><span class="line">    k8s-app: kubedns-autoscaler</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">  name: kubedns-autoscaler</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: 600</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kubedns-autoscaler</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 1</span><br><span class="line">      maxUnavailable: 1</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kubedns-autoscaler</span><br><span class="line">    spec:</span><br><span class="line">      affinity:</span><br><span class="line">        nodeAffinity:</span><br><span class="line">          preferredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - preference:</span><br><span class="line">              matchExpressions:</span><br><span class="line">              - key: node-role.kubernetes.io/master</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - &quot;true&quot;</span><br><span class="line">            weight: 100</span><br><span class="line">        podAntiAffinity:</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">          - labelSelector:</span><br><span class="line">              matchLabels:</span><br><span class="line">                k8s-app: kubedns-autoscaler</span><br><span class="line">            topologyKey: kubernetes.io/hostname</span><br><span class="line">      containers:</span><br><span class="line">      - command:</span><br><span class="line">        - /cluster-proportional-autoscaler</span><br><span class="line">        - --namespace=kube-system</span><br><span class="line">        - --configmap=kubedns-autoscaler</span><br><span class="line">        - --target=Deployment/kube-dns</span><br><span class="line">        - --default-params=&#123;&quot;linear&quot;:&#123;&quot;nodesPerReplica&quot;:10,&quot;min&quot;:2&#125;&#125;</span><br><span class="line">        - --logtostderr=true</span><br><span class="line">        - --v=2</span><br><span class="line">        image: gcr.io/google_containers/cluster-proportional-autoscaler-amd64:1.1.2</span><br><span class="line">        imagePullPolicy: IfNotPresent</span><br><span class="line">        name: autoscaler</span><br><span class="line">        resources:</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 20m</span><br><span class="line">            memory: 10Mi</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      nodeSelector:</span><br><span class="line">        beta.kubernetes.io/os: linux</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: default-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      serviceAccount: cluster-proportional-autoscaler</span><br><span class="line">      serviceAccountName: cluster-proportional-autoscaler</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">      tolerations:</span><br><span class="line">      - effect: NoSchedule</span><br><span class="line">        key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Equal</span><br></pre></td></tr></table></figure>
<p>我们看几个关键参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- --namespace=kube-system // autoscaler 配置所在的命名空间</span><br><span class="line">- --configmap=kubedns-autoscaler  // autoscaler 的 configmap 配置名称</span><br><span class="line">- --target=Deployment/kube-dns  // 表示要弹性伸缩的目标</span><br><span class="line">- --default-params=&#123;&quot;linear&quot;:&#123;&quot;nodesPerReplica&quot;:10,&quot;min&quot;:2&#125;&#125;  // 默认配置，这个配置可以由 configmap 覆盖</span><br><span class="line">- --logtostderr=true</span><br><span class="line">- --v=2</span><br></pre></td></tr></table></figure></p>
<p>我们可以定义 configmap 来配置 kubedns-autoscaler 的具体参数，configmap 中可以配置的内容如下：</p>
<h3 id="cluster-proportional-autoscaler-线性配置方式"><a href="#cluster-proportional-autoscaler-线性配置方式" class="headerlink" title="cluster-proportional-autoscaler 线性配置方式"></a>cluster-proportional-autoscaler 线性配置方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">  linear: |-</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;coresPerReplica&quot;: 2,</span><br><span class="line">      &quot;nodesPerReplica&quot;: 1,</span><br><span class="line">      &quot;min&quot;: 1,</span><br><span class="line">      &quot;max&quot;: 100,</span><br><span class="line">      &quot;preventSinglePointFailure&quot;: true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min：表示目标最小实例数，也就是 KubeDNS 最少的实例数量。</span><br><span class="line">coresPerReplica：当集群中有很多核（不是可用，而是总量）时，它决定 KubeDNS 的实例数量。</span><br><span class="line">nodesPerReplica：当集群中核数（不是可用，而是总量）少时，nodesPerReplica 来控制实例数量。</span><br></pre></td></tr></table></figure>
<p>整体来看，由下面这个公式，的出来最大的DNS实例数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replicas = max( ceil( cores * 1/coresPerReplica ) , ceil( nodes * 1/nodesPerReplica ) )</span><br><span class="line">replicas = min(replicas, max)</span><br><span class="line">replicas = max(replicas, min)</span><br></pre></td></tr></table></figure>
<h3 id="cluster-proportional-autoscaler-梯度配置方式"><a href="#cluster-proportional-autoscaler-梯度配置方式" class="headerlink" title="cluster-proportional-autoscaler 梯度配置方式"></a>cluster-proportional-autoscaler 梯度配置方式</h3><p>省略，也可以查看官方文档。</p>
<h3 id="cluster-proportional-autoscaler-水平扩容是如何实现的"><a href="#cluster-proportional-autoscaler-水平扩容是如何实现的" class="headerlink" title="cluster-proportional-autoscaler 水平扩容是如何实现的"></a>cluster-proportional-autoscaler 水平扩容是如何实现的</h3><ol>
<li>独立部署 cluster-proportional-autoscaler</li>
<li>autoscaler 从 APIServer（也就是K8S Master）拉取集群的核数和节点数，并根据这2者，确定一个 POD 最大实例数。</li>
<li>可以通过 configmap 配置 autoscaler 的参数，而不需要 重启 autoscaler 实例。</li>
<li>autoscaler 提供了【线性】及【梯度】2种扩容方式。</li>
</ol>
<p>这里边有一个小问题：通常，我们使用 ConfigMap 都是讲 ConfigMap 作为 volume ，Mount 到容器上，而 autoscaler 并没有使用这种方式，而是监听了K8S资源（通过 –configmap 及 –namespace 配置）从中获取配置，这种方式非常快而且高效，且不需要重启 autoscaler 实例。</p>
<p>扩容项目为：<a href="https://github.com/kubernetes-incubator/cluster-proportional-autoscaler" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/cluster-proportional-autoscaler</a></p>
<h3 id="cluster-proportional-autoscaler-不足之处"><a href="#cluster-proportional-autoscaler-不足之处" class="headerlink" title="cluster-proportional-autoscaler 不足之处"></a>cluster-proportional-autoscaler 不足之处</h3><p>基本上从上面可以知道，这个 扩容器，比较简单，最多就是根据集群的核数，以及节点数来配置最大实例数，其实这个扩缩容，并没有完整的实现出来，官方的意思是，Kubernetes 设想的 Horizontal Pod Autoscaler（<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/）" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/）</a> 是一个顶级的资源，需要根据集群中容器的CPU指标来衡量一个合理的值，但是当前这个 cluster-proportional-autoscaler ，仅仅是一个 DIY 实现，所谓的 DIY 实现，意思就是，你得自己手动来控制（比如通过更改 configmap 的方式），它并没有收集集群中容器的CPU利用率等数据，仅仅是一个比较粗略的水平调度实现而已。</p>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><h3 id="到底dnsmasq和kube-dns，谁提供的DNS上游能力？"><a href="#到底dnsmasq和kube-dns，谁提供的DNS上游能力？" class="headerlink" title="到底dnsmasq和kube-dns，谁提供的DNS上游能力？"></a>到底dnsmasq和kube-dns，谁提供的DNS上游能力？</h3><p>DNS 上游查询能力，也即是我们访问 非 K8S 内的域名，比如 youku.com，是 dnsmasq 向上游 DNS 服务器查询的，还是 kube-dns 来做的？</p>
<p>首先，dnsmasq 是 K8S 内 DNS 服务的入口，它决定内部的域名往 kube-dns 转发，其他的域名，往上游 DNS 服务器转发，然后将结果根据域名的TTL做缓存，加速DNS查询。</p>
<p>从上面文章的分析看，应该就是 dnsmasq 来上游查询处理的，但是，从 kube-dns 源码上看，其实 kube-dns 本身，也是具备提供 DNS 上游查询能力的。我们需要具体来看，这个上游查询，是谁来做的。</p>
<p>在 K8S 中，我们这样设置 DNS 上游，需要在 名为 kube-dns 的 ConfigMap 中来做。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: kube-dns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">data:</span><br><span class="line">  stubDomains: |</span><br><span class="line">    &#123;&quot;acme.local&quot;: [&quot;1.2.3.4&quot;]&#125;</span><br><span class="line">  upstreamNameservers: |</span><br><span class="line">    [&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;]</span><br></pre></td></tr></table></figure>
<p>上游DNS服务器字段：upstreamNameservers。</p>
<p>既然是需要配置 ConfigMap 来使配置生效，那么就看一下，是谁 使用了这个 ConfigMap 就行了。所以，我们回顾文章最开始部分的 deployment，看看谁将 ConfigMap 作为 Voloume 挂载到自己容器里使用就行了。</p>
<p>我们能够看到，使用 ConfigMap 的，有2个容器，分别是：</p>
<p>①：dnsmasq 容器<br>②：kube-dns 容器</p>
<p>kube-dns 容器使用这个 ConfigMap，肯定是可以根据其配置，使用配置中的 upstreamNameservers 中的地址来决定域名解析请求往何处转发的。但问题在于，它有这个能力，但不代表上游解析，真的由它来做。</p>
<p> 这里边需要注意的是，dnsmasq 容器也使用了这个配置，但并不是 dnsmasq 容器的 dnsmasq 进程直接使用的，而是 dnsmasq 容器中的 dnsmasq-nanny 进程来使用的，这个进程本身就是保姆进程，当 ConfigMap 变化后，dnsmasq-nanny 进程，便会解析配置，将配置中的 upstreamNameservers、stubDomains 内容，转换为 dnsmasq 进程能够识别的参数，然后杀死 原来的 dnsmasq 进程，启动一个新的。</p>
<p> 所以，在 KubeDNS 服务中，提供上游DNS解析能力的，是 dnsmasq 容器，而不是 kube-dns 容器。</p>
<h2 id="附录1：kube-dns使用何种数据结构实现DNS检索"><a href="#附录1：kube-dns使用何种数据结构实现DNS检索" class="headerlink" title="附录1：kube-dns使用何种数据结构实现DNS检索"></a>附录1：kube-dns使用何种数据结构实现DNS检索</h2><p>  后续有时间再补充。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="国南之境 微信支付">
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kubernetes/" rel="tag"># kubernetes</a>
          
            <a href="/tags/kubedns/" rel="tag"># kubedns</a>
          
            <a href="/tags/coredns/" rel="tag"># coredns</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/20/9/" rel="next" title="CoreDNS系列1：Kubernetes内部域名解析原理、弊端及优化方式">
                <i class="fa fa-chevron-left"></i> CoreDNS系列1：Kubernetes内部域名解析原理、弊端及优化方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/18/11/" rel="prev" title="K8S 如何使用具有配额限制的 ceph 共享存储">
                K8S 如何使用具有配额限制的 ceph 共享存储 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">国南之境</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#KubeDNS简述"><span class="nav-number">1.</span> <span class="nav-text">KubeDNS简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KubeDNS组件构成"><span class="nav-number">2.</span> <span class="nav-text">KubeDNS组件构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KubeDNS组件构成及实现"><span class="nav-number">3.</span> <span class="nav-text">KubeDNS组件构成及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dnsmasq-容器"><span class="nav-number">3.1.</span> <span class="nav-text">dnsmasq 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dnsmasq为KubeDNS提供缓存加速能力"><span class="nav-number">3.2.</span> <span class="nav-text">dnsmasq为KubeDNS提供缓存加速能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dnsmasq-容器内的进程组成及职责"><span class="nav-number">3.3.</span> <span class="nav-text">dnsmasq 容器内的进程组成及职责</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dnsmasq-容器负责让KubeDNS更新配置生效"><span class="nav-number">3.4.</span> <span class="nav-text">dnsmasq 容器负责让KubeDNS更新配置生效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kube-dns服务容器及实现原理"><span class="nav-number">3.5.</span> <span class="nav-text">kube-dns服务容器及实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-dns容器监听哪些K8S资源？"><span class="nav-number">3.5.1.</span> <span class="nav-text">kube-dns容器监听哪些K8S资源？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-dns使用何种数据结构实现DNS检索？"><span class="nav-number">3.5.2.</span> <span class="nav-text">kube-dns使用何种数据结构实现DNS检索？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dns-sidecar容器"><span class="nav-number">3.6.</span> <span class="nav-text">dns-sidecar容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dns-sidecar容器职责简述"><span class="nav-number">3.6.1.</span> <span class="nav-text">dns-sidecar容器职责简述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dns-sidecar-是如何做检测的"><span class="nav-number">3.6.2.</span> <span class="nav-text">dns-sidecar 是如何做检测的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KubeDNS-服务弹性水平伸缩"><span class="nav-number">4.</span> <span class="nav-text">KubeDNS 服务弹性水平伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#官方推荐方案：cluster-proportional-autoscaler"><span class="nav-number">4.1.</span> <span class="nav-text">官方推荐方案：cluster-proportional-autoscaler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-proportional-autoscaler-线性配置方式"><span class="nav-number">4.2.</span> <span class="nav-text">cluster-proportional-autoscaler 线性配置方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-proportional-autoscaler-梯度配置方式"><span class="nav-number">4.3.</span> <span class="nav-text">cluster-proportional-autoscaler 梯度配置方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-proportional-autoscaler-水平扩容是如何实现的"><span class="nav-number">4.4.</span> <span class="nav-text">cluster-proportional-autoscaler 水平扩容是如何实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cluster-proportional-autoscaler-不足之处"><span class="nav-number">4.5.</span> <span class="nav-text">cluster-proportional-autoscaler 不足之处</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Questions"><span class="nav-number">5.</span> <span class="nav-text">Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#到底dnsmasq和kube-dns，谁提供的DNS上游能力？"><span class="nav-number">5.1.</span> <span class="nav-text">到底dnsmasq和kube-dns，谁提供的DNS上游能力？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录1：kube-dns使用何种数据结构实现DNS检索"><span class="nav-number">6.</span> <span class="nav-text">附录1：kube-dns使用何种数据结构实现DNS检索</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">国南之境</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ui3Xsz1h0eom3WtwCf0d87Y6-gzGzoHsz", "WHVHSDeIgaLW1vEhsfWVw403");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
